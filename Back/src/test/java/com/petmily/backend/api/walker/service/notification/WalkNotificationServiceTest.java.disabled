package com.petmily.backend.api.walker.service.notification;

import com.petmily.backend.domain.walker.entity.WalkingTrack;
import com.petmily.backend.domain.walker.entity.WalkerBooking;
import com.petmily.backend.domain.walker.repository.WalkingTrackRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.redis.core.ListOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.test.util.ReflectionTestUtils;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("WalkNotificationService 테스트")
class WalkNotificationServiceTest {

    @Mock
    private GeminiMessageGenerator messageGenerator;

    @Mock
    private KakaoMessageSender messageSender;

    @Mock
    private WalkingTrackRepository walkingTrackRepository;

    @Mock
    private RedisTemplate<String, Object> redisTemplate;

    @Mock
    private ValueOperations<String, Object> valueOperations;

    @Mock
    private ListOperations<String, Object> listOperations;

    @InjectMocks
    private WalkNotificationService walkNotificationService;

    private WalkerBooking testBooking;
    private List<WalkingTrack> testTracks;
    private String testPetName;
    private String testOwnerContact;
    private String testMessage;

    @BeforeEach
    void setUp() {
        // Redis operations mock setup
        given(redisTemplate.opsForValue()).willReturn(valueOperations);
        given(redisTemplate.opsForList()).willReturn(listOperations);

        testPetName = "멍멍이";
        testOwnerContact = "010-1234-5678";
        testMessage = "🐕 멍멍이와 즐거운 산책을 시작합니다!";

        testBooking = new WalkerBooking();
        testBooking.setId(1L);
        testBooking.setUserId(1L);
        testBooking.setWalkerId(1L);
        testBooking.setPetId(1L);
        testBooking.setDate(LocalDateTime.now());
        testBooking.setDuration(60);
        testBooking.setStatus(WalkerBooking.BookingStatus.IN_PROGRESS);
        testBooking.setTotalPrice(15000.0);
        testBooking.setActualStartTime(LocalDateTime.now());

        WalkingTrack track1 = new WalkingTrack();
        track1.setId(1L);
        track1.setBookingId(1L);
        track1.setLatitude(37.5665);
        track1.setLongitude(126.9780);
        track1.setTimestamp(LocalDateTime.now());

        WalkingTrack track2 = new WalkingTrack();
        track2.setId(2L);
        track2.setBookingId(1L);
        track2.setLatitude(37.5670);
        track2.setLongitude(126.9785);
        track2.setTimestamp(LocalDateTime.now().plusMinutes(5));

        testTracks = Arrays.asList(track1, track2);

        // Set notification interval for testing
        ReflectionTestUtils.setField(walkNotificationService, "NOTIFICATION_INTERVAL_MINUTES", 10);
    }

    @Test
    @DisplayName("산책 시작 알림 발송 - 성공")
    void sendWalkStartNotification_Success() {
        // given
        given(messageGenerator.generateWalkStartMessage(testBooking, testPetName))
                .willReturn(testMessage);
        given(messageSender.isMessageSendingAvailable()).willReturn(false);

        // when
        walkNotificationService.sendWalkStartNotification(testBooking, testPetName, testOwnerContact);

        // then
        verify(messageGenerator).generateWalkStartMessage(testBooking, testPetName);
        verify(messageSender).logMessageForDevelopment(testOwnerContact, testMessage);
        verify(listOperations).rightPush(eq("walk:notification:count:1"), contains("START"));
        verify(redisTemplate).expire(eq("walk:notification:count:1"), eq(24L), eq(TimeUnit.HOURS));
    }

    @Test
    @DisplayName("산책 시작 알림 발송 - 메시지 생성 실패")
    void sendWalkStartNotification_MessageGenerationFailure() {
        // given
        given(messageGenerator.generateWalkStartMessage(testBooking, testPetName))
                .willThrow(new RuntimeException("Message generation failed"));

        // when
        walkNotificationService.sendWalkStartNotification(testBooking, testPetName, testOwnerContact);

        // then
        verify(messageGenerator).generateWalkStartMessage(testBooking, testPetName);
        verify(messageSender, never()).logMessageForDevelopment(any(), any());
        verify(listOperations, never()).rightPush(any(), any());
    }

    @Test
    @DisplayName("산책 진행 상황 알림 발송 - 성공")
    void sendWalkProgressNotification_Success() {
        // given
        String progressMessage = "🐕 멍멍이가 공원에서 즐겁게 뛰어놀고 있어요!";

        given(valueOperations.get("walk:notification:last:1"))
                .willReturn(null); // 첫 번째 진행 알림
        given(walkingTrackRepository.findByBookingIdOrderByTimestampAsc(1L))
                .willReturn(testTracks);
        given(messageGenerator.generateWalkProgressMessage(testBooking, testTracks, testPetName))
                .willReturn(progressMessage);
        given(messageSender.isMessageSendingAvailable()).willReturn(false);

        // when
        walkNotificationService.sendWalkProgressNotification(testBooking, testPetName, testOwnerContact);

        // then
        verify(valueOperations).get("walk:notification:last:1");
        verify(walkingTrackRepository).findByBookingIdOrderByTimestampAsc(1L);
        verify(messageGenerator).generateWalkProgressMessage(testBooking, testTracks, testPetName);
        verify(messageSender).logMessageForDevelopment(testOwnerContact, progressMessage);
        verify(listOperations).rightPush(eq("walk:notification:count:1"), contains("PROGRESS"));
        verify(valueOperations).set(eq("walk:notification:last:1"), anyString(), eq(24L), eq(TimeUnit.HOURS));
    }

    @Test
    @DisplayName("산책 진행 상황 알림 발송 - 알림 간격 미달로 발송 안함")
    void sendWalkProgressNotification_TooEarly() {
        // given
        String lastNotificationTime = LocalDateTime.now().minusMinutes(5).toString(); // 5분 전 알림 발송
        given(valueOperations.get("walk:notification:last:1"))
                .willReturn(lastNotificationTime);

        // when
        walkNotificationService.sendWalkProgressNotification(testBooking, testPetName, testOwnerContact);

        // then
        verify(valueOperations).get("walk:notification:last:1");
        verify(walkingTrackRepository, never()).findByBookingIdOrderByTimestampAsc(any());
        verify(messageGenerator, never()).generateWalkProgressMessage(any(), any(), any());
        verify(messageSender, never()).logMessageForDevelopment(any(), any());
    }

    @Test
    @DisplayName("산책 진행 상황 알림 발송 - 충분한 시간 경과 후 발송")
    void sendWalkProgressNotification_AfterInterval() {
        // given
        String lastNotificationTime = LocalDateTime.now().minusMinutes(15).toString(); // 15분 전 알림 발송
        String progressMessage = "🐕 멍멍이가 활발하게 산책 중이에요!";

        given(valueOperations.get("walk:notification:last:1"))
                .willReturn(lastNotificationTime);
        given(walkingTrackRepository.findByBookingIdOrderByTimestampAsc(1L))
                .willReturn(testTracks);
        given(messageGenerator.generateWalkProgressMessage(testBooking, testTracks, testPetName))
                .willReturn(progressMessage);
        given(messageSender.isMessageSendingAvailable()).willReturn(false);

        // when
        walkNotificationService.sendWalkProgressNotification(testBooking, testPetName, testOwnerContact);

        // then
        verify(valueOperations).get("walk:notification:last:1");
        verify(walkingTrackRepository).findByBookingIdOrderByTimestampAsc(1L);
        verify(messageGenerator).generateWalkProgressMessage(testBooking, testTracks, testPetName);
        verify(messageSender).logMessageForDevelopment(testOwnerContact, progressMessage);
        verify(valueOperations).set(eq("walk:notification:last:1"), anyString(), eq(24L), eq(TimeUnit.HOURS));
    }

    @Test
    @DisplayName("산책 완료 알림 발송 - 성공")
    void sendWalkCompleteNotification_Success() {
        // given
        String completeMessage = "🎉 멍멍이와의 즐거운 산책이 완료되었습니다!";

        given(walkingTrackRepository.findByBookingIdOrderByTimestampAsc(1L))
                .willReturn(testTracks);
        given(messageGenerator.generateWalkCompleteMessage(testBooking, testTracks, testPetName))
                .willReturn(completeMessage);
        given(messageSender.isMessageSendingAvailable()).willReturn(false);

        // when
        walkNotificationService.sendWalkCompleteNotification(testBooking, testPetName, testOwnerContact);

        // then
        verify(walkingTrackRepository).findByBookingIdOrderByTimestampAsc(1L);
        verify(messageGenerator).generateWalkCompleteMessage(testBooking, testTracks, testPetName);
        verify(messageSender).logMessageForDevelopment(testOwnerContact, completeMessage);
        verify(listOperations).rightPush(eq("walk:notification:count:1"), contains("COMPLETE"));
        verify(redisTemplate).delete("walk:notification:last:1");
        verify(redisTemplate).delete("walk:notification:count:1");
    }

    @Test
    @DisplayName("정지 상태 알림 발송 - 성공")
    void sendStationaryAlertNotification_Success() {
        // given
        int stationaryMinutes = 5;
        String alertMessage = "⚠️ 멍멍이가 같은 곳에 5분째 머물고 있어요";

        given(messageGenerator.generateStationaryAlertMessage(testPetName, stationaryMinutes))
                .willReturn(alertMessage);
        given(messageSender.isMessageSendingAvailable()).willReturn(false);

        // when
        walkNotificationService.sendStationaryAlertNotification(testBooking, testPetName, testOwnerContact, stationaryMinutes);

        // then
        verify(messageGenerator).generateStationaryAlertMessage(testPetName, stationaryMinutes);
        verify(messageSender).logMessageForDevelopment(testOwnerContact, alertMessage);
        verify(listOperations).rightPush(eq("walk:notification:count:1"), contains("STATIONARY_ALERT"));
    }

    @Test
    @DisplayName("정지 상태 알림 발송 - 메시지 생성 실패")
    void sendStationaryAlertNotification_MessageGenerationFailure() {
        // given
        int stationaryMinutes = 5;
        given(messageGenerator.generateStationaryAlertMessage(testPetName, stationaryMinutes))
                .willThrow(new RuntimeException("Alert message generation failed"));

        // when
        walkNotificationService.sendStationaryAlertNotification(testBooking, testPetName, testOwnerContact, stationaryMinutes);

        // then
        verify(messageGenerator).generateStationaryAlertMessage(testPetName, stationaryMinutes);
        verify(messageSender, never()).logMessageForDevelopment(any(), any());
        verify(listOperations, never()).rightPush(any(), any());
    }

    @Test
    @DisplayName("메시지 발송 가능 환경에서의 알림 처리")
    void sendNotification_MessageSendingAvailable() {
        // given
        given(messageGenerator.generateWalkStartMessage(testBooking, testPetName))
                .willReturn(testMessage);
        given(messageSender.isMessageSendingAvailable()).willReturn(true);

        // when
        walkNotificationService.sendWalkStartNotification(testBooking, testPetName, testOwnerContact);

        // then
        verify(messageGenerator).generateWalkStartMessage(testBooking, testPetName);
        verify(messageSender).isMessageSendingAvailable();
        verify(messageSender).logMessageForDevelopment(testOwnerContact, testMessage);
        verify(listOperations).rightPush(eq("walk:notification:count:1"), contains("START"));
    }

    @Test
    @DisplayName("알림 발송 이력 조회 - 성공")
    void getNotificationHistory_Success() {
        // given
        List<Object> expectedHistory = Arrays.asList(
                "START:2024-01-01T10:00:00",
                "PROGRESS:2024-01-01T10:10:00",
                "COMPLETE:2024-01-01T11:00:00"
        );

        given(listOperations.range("walk:notification:count:1", 0, -1))
                .willReturn(expectedHistory);

        // when
        List<Object> actualHistory = walkNotificationService.getNotificationHistory(1L);

        // then
        assertThat(actualHistory).isNotNull();
        assertThat(actualHistory).hasSize(3);
        assertThat(actualHistory).containsExactlyElementsOf(expectedHistory);

        verify(listOperations).range("walk:notification:count:1", 0, -1);
    }

    @Test
    @DisplayName("알림 발송 이력 조회 - 빈 이력")
    void getNotificationHistory_EmptyHistory() {
        // given
        given(listOperations.range("walk:notification:count:1", 0, -1))
                .willReturn(Arrays.asList());

        // when
        List<Object> actualHistory = walkNotificationService.getNotificationHistory(1L);

        // then
        assertThat(actualHistory).isNotNull();
        assertThat(actualHistory).isEmpty();

        verify(listOperations).range("walk:notification:count:1", 0, -1);
    }

    @Test
    @DisplayName("진행 상황 알림 발송 여부 확인 - 첫 번째 알림")
    void shouldSendProgressNotification_FirstNotification() {
        // given
        given(valueOperations.get("walk:notification:last:1"))
                .willReturn(null);

        // when
        boolean result = ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "shouldSendProgressNotification",
                1L
        );

        // then
        assertThat(result).isTrue();
        verify(valueOperations).get("walk:notification:last:1");
    }

    @Test
    @DisplayName("진행 상황 알림 발송 여부 확인 - 간격 충족")
    void shouldSendProgressNotification_IntervalMet() {
        // given
        String lastNotificationTime = LocalDateTime.now().minusMinutes(15).toString();
        given(valueOperations.get("walk:notification:last:1"))
                .willReturn(lastNotificationTime);

        // when
        boolean result = ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "shouldSendProgressNotification",
                1L
        );

        // then
        assertThat(result).isTrue();
        verify(valueOperations).get("walk:notification:last:1");
    }

    @Test
    @DisplayName("진행 상황 알림 발송 여부 확인 - 간격 미충족")
    void shouldSendProgressNotification_IntervalNotMet() {
        // given
        String lastNotificationTime = LocalDateTime.now().minusMinutes(5).toString();
        given(valueOperations.get("walk:notification:last:1"))
                .willReturn(lastNotificationTime);

        // when
        boolean result = ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "shouldSendProgressNotification",
                1L
        );

        // then
        assertThat(result).isFalse();
        verify(valueOperations).get("walk:notification:last:1");
    }

    @Test
    @DisplayName("마지막 알림 발송 시간 업데이트")
    void updateLastNotificationTime() {
        // when
        ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "updateLastNotificationTime",
                1L
        );

        // then
        ArgumentCaptor<String> keyCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> valueCaptor = ArgumentCaptor.forClass(String.class);

        verify(valueOperations).set(
                keyCaptor.capture(),
                valueCaptor.capture(),
                eq(24L),
                eq(TimeUnit.HOURS)
        );

        assertThat(keyCaptor.getValue()).isEqualTo("walk:notification:last:1");
        assertThat(valueCaptor.getValue()).isNotNull();
        assertThat(valueCaptor.getValue()).contains("T"); // LocalDateTime format check
    }

    @Test
    @DisplayName("알림 발송 기록 저장")
    void saveNotificationRecord() {
        // when
        ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "saveNotificationRecord",
                1L,
                "TEST"
        );

        // then
        ArgumentCaptor<String> keyCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> valueCaptor = ArgumentCaptor.forClass(String.class);

        verify(listOperations).rightPush(keyCaptor.capture(), valueCaptor.capture());
        verify(redisTemplate).expire(eq("walk:notification:count:1"), eq(24L), eq(TimeUnit.HOURS));

        assertThat(keyCaptor.getValue()).isEqualTo("walk:notification:count:1");
        assertThat(valueCaptor.getValue()).startsWith("TEST:");
        assertThat(valueCaptor.getValue()).contains("T"); // LocalDateTime format check
    }

    @Test
    @DisplayName("알림 관련 데이터 정리")
    void cleanupNotificationData() {
        // when
        ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "cleanupNotificationData",
                1L
        );

        // then
        verify(redisTemplate).delete("walk:notification:last:1");
        verify(redisTemplate).delete("walk:notification:count:1");
    }

    @Test
    @DisplayName("실제 메시지 발송 처리 - 개발 환경")
    void sendNotification_DevelopmentEnvironment() {
        // given
        given(messageSender.isMessageSendingAvailable()).willReturn(false);

        // when
        boolean result = ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "sendNotification",
                testOwnerContact,
                testMessage
        );

        // then
        assertThat(result).isTrue();
        verify(messageSender).isMessageSendingAvailable();
        verify(messageSender).logMessageForDevelopment(testOwnerContact, testMessage);
    }

    @Test
    @DisplayName("실제 메시지 발송 처리 - 운영 환경")
    void sendNotification_ProductionEnvironment() {
        // given
        given(messageSender.isMessageSendingAvailable()).willReturn(true);

        // when
        boolean result = ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "sendNotification",
                testOwnerContact,
                testMessage
        );

        // then
        assertThat(result).isTrue();
        verify(messageSender).isMessageSendingAvailable();
        verify(messageSender).logMessageForDevelopment(testOwnerContact, testMessage);
    }

    @Test
    @DisplayName("산책 완료 알림에서 데이터 정리 확인")
    void sendWalkCompleteNotification_DataCleanup() {
        // given
        String completeMessage = "🎉 산책 완료!";

        given(walkingTrackRepository.findByBookingIdOrderByTimestampAsc(1L))
                .willReturn(testTracks);
        given(messageGenerator.generateWalkCompleteMessage(testBooking, testTracks, testPetName))
                .willReturn(completeMessage);
        given(messageSender.isMessageSendingAvailable()).willReturn(false);

        // when
        walkNotificationService.sendWalkCompleteNotification(testBooking, testPetName, testOwnerContact);

        // then
        // 데이터 정리가 수행되는지 확인
        verify(redisTemplate).delete("walk:notification:last:1");
        verify(redisTemplate).delete("walk:notification:count:1");

        // 완료 알림 기록도 저장되는지 확인
        verify(listOperations).rightPush(eq("walk:notification:count:1"), contains("COMPLETE"));
    }
}