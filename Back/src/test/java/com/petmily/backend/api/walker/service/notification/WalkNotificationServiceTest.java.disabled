package com.petmily.backend.api.walker.service.notification;

import com.petmily.backend.domain.walker.entity.WalkingTrack;
import com.petmily.backend.domain.walker.entity.WalkerBooking;
import com.petmily.backend.domain.walker.repository.WalkingTrackRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.redis.core.ListOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.test.util.ReflectionTestUtils;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("WalkNotificationService í…ŒìŠ¤íŠ¸")
class WalkNotificationServiceTest {

    @Mock
    private GeminiMessageGenerator messageGenerator;

    @Mock
    private KakaoMessageSender messageSender;

    @Mock
    private WalkingTrackRepository walkingTrackRepository;

    @Mock
    private RedisTemplate<String, Object> redisTemplate;

    @Mock
    private ValueOperations<String, Object> valueOperations;

    @Mock
    private ListOperations<String, Object> listOperations;

    @InjectMocks
    private WalkNotificationService walkNotificationService;

    private WalkerBooking testBooking;
    private List<WalkingTrack> testTracks;
    private String testPetName;
    private String testOwnerContact;
    private String testMessage;

    @BeforeEach
    void setUp() {
        // Redis operations mock setup
        given(redisTemplate.opsForValue()).willReturn(valueOperations);
        given(redisTemplate.opsForList()).willReturn(listOperations);

        testPetName = "ë©ë©ì´";
        testOwnerContact = "010-1234-5678";
        testMessage = "ğŸ• ë©ë©ì´ì™€ ì¦ê±°ìš´ ì‚°ì±…ì„ ì‹œì‘í•©ë‹ˆë‹¤!";

        testBooking = new WalkerBooking();
        testBooking.setId(1L);
        testBooking.setUserId(1L);
        testBooking.setWalkerId(1L);
        testBooking.setPetId(1L);
        testBooking.setDate(LocalDateTime.now());
        testBooking.setDuration(60);
        testBooking.setStatus(WalkerBooking.BookingStatus.IN_PROGRESS);
        testBooking.setTotalPrice(15000.0);
        testBooking.setActualStartTime(LocalDateTime.now());

        WalkingTrack track1 = new WalkingTrack();
        track1.setId(1L);
        track1.setBookingId(1L);
        track1.setLatitude(37.5665);
        track1.setLongitude(126.9780);
        track1.setTimestamp(LocalDateTime.now());

        WalkingTrack track2 = new WalkingTrack();
        track2.setId(2L);
        track2.setBookingId(1L);
        track2.setLatitude(37.5670);
        track2.setLongitude(126.9785);
        track2.setTimestamp(LocalDateTime.now().plusMinutes(5));

        testTracks = Arrays.asList(track1, track2);

        // Set notification interval for testing
        ReflectionTestUtils.setField(walkNotificationService, "NOTIFICATION_INTERVAL_MINUTES", 10);
    }

    @Test
    @DisplayName("ì‚°ì±… ì‹œì‘ ì•Œë¦¼ ë°œì†¡ - ì„±ê³µ")
    void sendWalkStartNotification_Success() {
        // given
        given(messageGenerator.generateWalkStartMessage(testBooking, testPetName))
                .willReturn(testMessage);
        given(messageSender.isMessageSendingAvailable()).willReturn(false);

        // when
        walkNotificationService.sendWalkStartNotification(testBooking, testPetName, testOwnerContact);

        // then
        verify(messageGenerator).generateWalkStartMessage(testBooking, testPetName);
        verify(messageSender).logMessageForDevelopment(testOwnerContact, testMessage);
        verify(listOperations).rightPush(eq("walk:notification:count:1"), contains("START"));
        verify(redisTemplate).expire(eq("walk:notification:count:1"), eq(24L), eq(TimeUnit.HOURS));
    }

    @Test
    @DisplayName("ì‚°ì±… ì‹œì‘ ì•Œë¦¼ ë°œì†¡ - ë©”ì‹œì§€ ìƒì„± ì‹¤íŒ¨")
    void sendWalkStartNotification_MessageGenerationFailure() {
        // given
        given(messageGenerator.generateWalkStartMessage(testBooking, testPetName))
                .willThrow(new RuntimeException("Message generation failed"));

        // when
        walkNotificationService.sendWalkStartNotification(testBooking, testPetName, testOwnerContact);

        // then
        verify(messageGenerator).generateWalkStartMessage(testBooking, testPetName);
        verify(messageSender, never()).logMessageForDevelopment(any(), any());
        verify(listOperations, never()).rightPush(any(), any());
    }

    @Test
    @DisplayName("ì‚°ì±… ì§„í–‰ ìƒí™© ì•Œë¦¼ ë°œì†¡ - ì„±ê³µ")
    void sendWalkProgressNotification_Success() {
        // given
        String progressMessage = "ğŸ• ë©ë©ì´ê°€ ê³µì›ì—ì„œ ì¦ê²ê²Œ ë›°ì–´ë†€ê³  ìˆì–´ìš”!";

        given(valueOperations.get("walk:notification:last:1"))
                .willReturn(null); // ì²« ë²ˆì§¸ ì§„í–‰ ì•Œë¦¼
        given(walkingTrackRepository.findByBookingIdOrderByTimestampAsc(1L))
                .willReturn(testTracks);
        given(messageGenerator.generateWalkProgressMessage(testBooking, testTracks, testPetName))
                .willReturn(progressMessage);
        given(messageSender.isMessageSendingAvailable()).willReturn(false);

        // when
        walkNotificationService.sendWalkProgressNotification(testBooking, testPetName, testOwnerContact);

        // then
        verify(valueOperations).get("walk:notification:last:1");
        verify(walkingTrackRepository).findByBookingIdOrderByTimestampAsc(1L);
        verify(messageGenerator).generateWalkProgressMessage(testBooking, testTracks, testPetName);
        verify(messageSender).logMessageForDevelopment(testOwnerContact, progressMessage);
        verify(listOperations).rightPush(eq("walk:notification:count:1"), contains("PROGRESS"));
        verify(valueOperations).set(eq("walk:notification:last:1"), anyString(), eq(24L), eq(TimeUnit.HOURS));
    }

    @Test
    @DisplayName("ì‚°ì±… ì§„í–‰ ìƒí™© ì•Œë¦¼ ë°œì†¡ - ì•Œë¦¼ ê°„ê²© ë¯¸ë‹¬ë¡œ ë°œì†¡ ì•ˆí•¨")
    void sendWalkProgressNotification_TooEarly() {
        // given
        String lastNotificationTime = LocalDateTime.now().minusMinutes(5).toString(); // 5ë¶„ ì „ ì•Œë¦¼ ë°œì†¡
        given(valueOperations.get("walk:notification:last:1"))
                .willReturn(lastNotificationTime);

        // when
        walkNotificationService.sendWalkProgressNotification(testBooking, testPetName, testOwnerContact);

        // then
        verify(valueOperations).get("walk:notification:last:1");
        verify(walkingTrackRepository, never()).findByBookingIdOrderByTimestampAsc(any());
        verify(messageGenerator, never()).generateWalkProgressMessage(any(), any(), any());
        verify(messageSender, never()).logMessageForDevelopment(any(), any());
    }

    @Test
    @DisplayName("ì‚°ì±… ì§„í–‰ ìƒí™© ì•Œë¦¼ ë°œì†¡ - ì¶©ë¶„í•œ ì‹œê°„ ê²½ê³¼ í›„ ë°œì†¡")
    void sendWalkProgressNotification_AfterInterval() {
        // given
        String lastNotificationTime = LocalDateTime.now().minusMinutes(15).toString(); // 15ë¶„ ì „ ì•Œë¦¼ ë°œì†¡
        String progressMessage = "ğŸ• ë©ë©ì´ê°€ í™œë°œí•˜ê²Œ ì‚°ì±… ì¤‘ì´ì—ìš”!";

        given(valueOperations.get("walk:notification:last:1"))
                .willReturn(lastNotificationTime);
        given(walkingTrackRepository.findByBookingIdOrderByTimestampAsc(1L))
                .willReturn(testTracks);
        given(messageGenerator.generateWalkProgressMessage(testBooking, testTracks, testPetName))
                .willReturn(progressMessage);
        given(messageSender.isMessageSendingAvailable()).willReturn(false);

        // when
        walkNotificationService.sendWalkProgressNotification(testBooking, testPetName, testOwnerContact);

        // then
        verify(valueOperations).get("walk:notification:last:1");
        verify(walkingTrackRepository).findByBookingIdOrderByTimestampAsc(1L);
        verify(messageGenerator).generateWalkProgressMessage(testBooking, testTracks, testPetName);
        verify(messageSender).logMessageForDevelopment(testOwnerContact, progressMessage);
        verify(valueOperations).set(eq("walk:notification:last:1"), anyString(), eq(24L), eq(TimeUnit.HOURS));
    }

    @Test
    @DisplayName("ì‚°ì±… ì™„ë£Œ ì•Œë¦¼ ë°œì†¡ - ì„±ê³µ")
    void sendWalkCompleteNotification_Success() {
        // given
        String completeMessage = "ğŸ‰ ë©ë©ì´ì™€ì˜ ì¦ê±°ìš´ ì‚°ì±…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!";

        given(walkingTrackRepository.findByBookingIdOrderByTimestampAsc(1L))
                .willReturn(testTracks);
        given(messageGenerator.generateWalkCompleteMessage(testBooking, testTracks, testPetName))
                .willReturn(completeMessage);
        given(messageSender.isMessageSendingAvailable()).willReturn(false);

        // when
        walkNotificationService.sendWalkCompleteNotification(testBooking, testPetName, testOwnerContact);

        // then
        verify(walkingTrackRepository).findByBookingIdOrderByTimestampAsc(1L);
        verify(messageGenerator).generateWalkCompleteMessage(testBooking, testTracks, testPetName);
        verify(messageSender).logMessageForDevelopment(testOwnerContact, completeMessage);
        verify(listOperations).rightPush(eq("walk:notification:count:1"), contains("COMPLETE"));
        verify(redisTemplate).delete("walk:notification:last:1");
        verify(redisTemplate).delete("walk:notification:count:1");
    }

    @Test
    @DisplayName("ì •ì§€ ìƒíƒœ ì•Œë¦¼ ë°œì†¡ - ì„±ê³µ")
    void sendStationaryAlertNotification_Success() {
        // given
        int stationaryMinutes = 5;
        String alertMessage = "âš ï¸ ë©ë©ì´ê°€ ê°™ì€ ê³³ì— 5ë¶„ì§¸ ë¨¸ë¬¼ê³  ìˆì–´ìš”";

        given(messageGenerator.generateStationaryAlertMessage(testPetName, stationaryMinutes))
                .willReturn(alertMessage);
        given(messageSender.isMessageSendingAvailable()).willReturn(false);

        // when
        walkNotificationService.sendStationaryAlertNotification(testBooking, testPetName, testOwnerContact, stationaryMinutes);

        // then
        verify(messageGenerator).generateStationaryAlertMessage(testPetName, stationaryMinutes);
        verify(messageSender).logMessageForDevelopment(testOwnerContact, alertMessage);
        verify(listOperations).rightPush(eq("walk:notification:count:1"), contains("STATIONARY_ALERT"));
    }

    @Test
    @DisplayName("ì •ì§€ ìƒíƒœ ì•Œë¦¼ ë°œì†¡ - ë©”ì‹œì§€ ìƒì„± ì‹¤íŒ¨")
    void sendStationaryAlertNotification_MessageGenerationFailure() {
        // given
        int stationaryMinutes = 5;
        given(messageGenerator.generateStationaryAlertMessage(testPetName, stationaryMinutes))
                .willThrow(new RuntimeException("Alert message generation failed"));

        // when
        walkNotificationService.sendStationaryAlertNotification(testBooking, testPetName, testOwnerContact, stationaryMinutes);

        // then
        verify(messageGenerator).generateStationaryAlertMessage(testPetName, stationaryMinutes);
        verify(messageSender, never()).logMessageForDevelopment(any(), any());
        verify(listOperations, never()).rightPush(any(), any());
    }

    @Test
    @DisplayName("ë©”ì‹œì§€ ë°œì†¡ ê°€ëŠ¥ í™˜ê²½ì—ì„œì˜ ì•Œë¦¼ ì²˜ë¦¬")
    void sendNotification_MessageSendingAvailable() {
        // given
        given(messageGenerator.generateWalkStartMessage(testBooking, testPetName))
                .willReturn(testMessage);
        given(messageSender.isMessageSendingAvailable()).willReturn(true);

        // when
        walkNotificationService.sendWalkStartNotification(testBooking, testPetName, testOwnerContact);

        // then
        verify(messageGenerator).generateWalkStartMessage(testBooking, testPetName);
        verify(messageSender).isMessageSendingAvailable();
        verify(messageSender).logMessageForDevelopment(testOwnerContact, testMessage);
        verify(listOperations).rightPush(eq("walk:notification:count:1"), contains("START"));
    }

    @Test
    @DisplayName("ì•Œë¦¼ ë°œì†¡ ì´ë ¥ ì¡°íšŒ - ì„±ê³µ")
    void getNotificationHistory_Success() {
        // given
        List<Object> expectedHistory = Arrays.asList(
                "START:2024-01-01T10:00:00",
                "PROGRESS:2024-01-01T10:10:00",
                "COMPLETE:2024-01-01T11:00:00"
        );

        given(listOperations.range("walk:notification:count:1", 0, -1))
                .willReturn(expectedHistory);

        // when
        List<Object> actualHistory = walkNotificationService.getNotificationHistory(1L);

        // then
        assertThat(actualHistory).isNotNull();
        assertThat(actualHistory).hasSize(3);
        assertThat(actualHistory).containsExactlyElementsOf(expectedHistory);

        verify(listOperations).range("walk:notification:count:1", 0, -1);
    }

    @Test
    @DisplayName("ì•Œë¦¼ ë°œì†¡ ì´ë ¥ ì¡°íšŒ - ë¹ˆ ì´ë ¥")
    void getNotificationHistory_EmptyHistory() {
        // given
        given(listOperations.range("walk:notification:count:1", 0, -1))
                .willReturn(Arrays.asList());

        // when
        List<Object> actualHistory = walkNotificationService.getNotificationHistory(1L);

        // then
        assertThat(actualHistory).isNotNull();
        assertThat(actualHistory).isEmpty();

        verify(listOperations).range("walk:notification:count:1", 0, -1);
    }

    @Test
    @DisplayName("ì§„í–‰ ìƒí™© ì•Œë¦¼ ë°œì†¡ ì—¬ë¶€ í™•ì¸ - ì²« ë²ˆì§¸ ì•Œë¦¼")
    void shouldSendProgressNotification_FirstNotification() {
        // given
        given(valueOperations.get("walk:notification:last:1"))
                .willReturn(null);

        // when
        boolean result = ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "shouldSendProgressNotification",
                1L
        );

        // then
        assertThat(result).isTrue();
        verify(valueOperations).get("walk:notification:last:1");
    }

    @Test
    @DisplayName("ì§„í–‰ ìƒí™© ì•Œë¦¼ ë°œì†¡ ì—¬ë¶€ í™•ì¸ - ê°„ê²© ì¶©ì¡±")
    void shouldSendProgressNotification_IntervalMet() {
        // given
        String lastNotificationTime = LocalDateTime.now().minusMinutes(15).toString();
        given(valueOperations.get("walk:notification:last:1"))
                .willReturn(lastNotificationTime);

        // when
        boolean result = ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "shouldSendProgressNotification",
                1L
        );

        // then
        assertThat(result).isTrue();
        verify(valueOperations).get("walk:notification:last:1");
    }

    @Test
    @DisplayName("ì§„í–‰ ìƒí™© ì•Œë¦¼ ë°œì†¡ ì—¬ë¶€ í™•ì¸ - ê°„ê²© ë¯¸ì¶©ì¡±")
    void shouldSendProgressNotification_IntervalNotMet() {
        // given
        String lastNotificationTime = LocalDateTime.now().minusMinutes(5).toString();
        given(valueOperations.get("walk:notification:last:1"))
                .willReturn(lastNotificationTime);

        // when
        boolean result = ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "shouldSendProgressNotification",
                1L
        );

        // then
        assertThat(result).isFalse();
        verify(valueOperations).get("walk:notification:last:1");
    }

    @Test
    @DisplayName("ë§ˆì§€ë§‰ ì•Œë¦¼ ë°œì†¡ ì‹œê°„ ì—…ë°ì´íŠ¸")
    void updateLastNotificationTime() {
        // when
        ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "updateLastNotificationTime",
                1L
        );

        // then
        ArgumentCaptor<String> keyCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> valueCaptor = ArgumentCaptor.forClass(String.class);

        verify(valueOperations).set(
                keyCaptor.capture(),
                valueCaptor.capture(),
                eq(24L),
                eq(TimeUnit.HOURS)
        );

        assertThat(keyCaptor.getValue()).isEqualTo("walk:notification:last:1");
        assertThat(valueCaptor.getValue()).isNotNull();
        assertThat(valueCaptor.getValue()).contains("T"); // LocalDateTime format check
    }

    @Test
    @DisplayName("ì•Œë¦¼ ë°œì†¡ ê¸°ë¡ ì €ì¥")
    void saveNotificationRecord() {
        // when
        ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "saveNotificationRecord",
                1L,
                "TEST"
        );

        // then
        ArgumentCaptor<String> keyCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> valueCaptor = ArgumentCaptor.forClass(String.class);

        verify(listOperations).rightPush(keyCaptor.capture(), valueCaptor.capture());
        verify(redisTemplate).expire(eq("walk:notification:count:1"), eq(24L), eq(TimeUnit.HOURS));

        assertThat(keyCaptor.getValue()).isEqualTo("walk:notification:count:1");
        assertThat(valueCaptor.getValue()).startsWith("TEST:");
        assertThat(valueCaptor.getValue()).contains("T"); // LocalDateTime format check
    }

    @Test
    @DisplayName("ì•Œë¦¼ ê´€ë ¨ ë°ì´í„° ì •ë¦¬")
    void cleanupNotificationData() {
        // when
        ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "cleanupNotificationData",
                1L
        );

        // then
        verify(redisTemplate).delete("walk:notification:last:1");
        verify(redisTemplate).delete("walk:notification:count:1");
    }

    @Test
    @DisplayName("ì‹¤ì œ ë©”ì‹œì§€ ë°œì†¡ ì²˜ë¦¬ - ê°œë°œ í™˜ê²½")
    void sendNotification_DevelopmentEnvironment() {
        // given
        given(messageSender.isMessageSendingAvailable()).willReturn(false);

        // when
        boolean result = ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "sendNotification",
                testOwnerContact,
                testMessage
        );

        // then
        assertThat(result).isTrue();
        verify(messageSender).isMessageSendingAvailable();
        verify(messageSender).logMessageForDevelopment(testOwnerContact, testMessage);
    }

    @Test
    @DisplayName("ì‹¤ì œ ë©”ì‹œì§€ ë°œì†¡ ì²˜ë¦¬ - ìš´ì˜ í™˜ê²½")
    void sendNotification_ProductionEnvironment() {
        // given
        given(messageSender.isMessageSendingAvailable()).willReturn(true);

        // when
        boolean result = ReflectionTestUtils.invokeMethod(
                walkNotificationService,
                "sendNotification",
                testOwnerContact,
                testMessage
        );

        // then
        assertThat(result).isTrue();
        verify(messageSender).isMessageSendingAvailable();
        verify(messageSender).logMessageForDevelopment(testOwnerContact, testMessage);
    }

    @Test
    @DisplayName("ì‚°ì±… ì™„ë£Œ ì•Œë¦¼ì—ì„œ ë°ì´í„° ì •ë¦¬ í™•ì¸")
    void sendWalkCompleteNotification_DataCleanup() {
        // given
        String completeMessage = "ğŸ‰ ì‚°ì±… ì™„ë£Œ!";

        given(walkingTrackRepository.findByBookingIdOrderByTimestampAsc(1L))
                .willReturn(testTracks);
        given(messageGenerator.generateWalkCompleteMessage(testBooking, testTracks, testPetName))
                .willReturn(completeMessage);
        given(messageSender.isMessageSendingAvailable()).willReturn(false);

        // when
        walkNotificationService.sendWalkCompleteNotification(testBooking, testPetName, testOwnerContact);

        // then
        // ë°ì´í„° ì •ë¦¬ê°€ ìˆ˜í–‰ë˜ëŠ”ì§€ í™•ì¸
        verify(redisTemplate).delete("walk:notification:last:1");
        verify(redisTemplate).delete("walk:notification:count:1");

        // ì™„ë£Œ ì•Œë¦¼ ê¸°ë¡ë„ ì €ì¥ë˜ëŠ”ì§€ í™•ì¸
        verify(listOperations).rightPush(eq("walk:notification:count:1"), contains("COMPLETE"));
    }
}